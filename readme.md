## DFS & BFS

```
1.visited 리스트 생성
2.연결 상태 리스트 생성
3.시작 노드를 리스트에 담기
4.노드를 꺼내고 연결 노드를 담기
5.이 때 노드를 어떻게 꺼내냐에 따라 DFS/BFS가 나뉨
(DFS : Stack 사용 // BFS : Queue 사용)
```

## 이분탐색유형

- 정렬된 값을 나눠서 값을 찾아가는 탐색

```
1. 정렬된 데이터가 있다. (정렬된 데이터를 잘 고르는 게 중요) -> 시간
2. 정렬된 데이터와 상관관계가 있는 상태(값)이 존재한다. -> 그 정렬된 데이터로부터 방향성을 가진 상태를 찾을 수 있어야 함
3. 정렬된 데이터의 적정값을 찾거나 최대/최소값을 구해야 한다. -> 조건을 만족하는 처리 인원 수를 만드는 적정 시간
```

## 완전 탐색 유형 (브루트 포스) + 순열/조합

- 모든 경우의 수를 탐색
- 시간 초과에 대한 리스크가 있지만 생각보다 자주 브루트 포스만으로 문제가 풀리고 빠르게 구현해서 테스트할 수 있다는 장점 때문에 해법에 접근하는 과정에서 첫 시도로 좋은 방법

```
선형 구조 -> 순차탐색:  반복문 사용
비선형 구조 -> 그래프 (DFS, BFS)
```

## 그래프

- 정점(Node)과 간선(Edge)으로 이어진 자료구조
- 각 유형마다 사용하는 특유의 방법이 있고 이를 바로바로 활용할 수 있는 능력이 문제를 풀 때 요구됨

### 1. 그래프 표현법

1. 인접행렬

```
[
    [0,1,0],
    [1,0,1],
    [0,1,0]
]

- 각 노드마다 대응되는 배열이 있으며 모든 노드에 대한 연결 상태를 표현
- 두 노드가 연결되어 있는지 확인하는 것이 빠름
- 특정 노드와 연결된 모든 노드를 찾는 건 느림 (간선이 많을수록 유리)
- 많은 메모리 사용 (고정된 n^2 만큼의 메모리 필요)
```

2. 인접리스트

```
[
    [1],
    [0,2],
    [1]
]

- 각 노드마다 대응되는 리스트가 있으며 연결된 노드만 표현
- 두 노드가 연결되어 있는지 확인하는 것이 느림
- 특정 노드와 연결된 모든 노드를 찾는 건 빠름 (간선이 적을수록 유리)
- 필요한 메모리 사용
```

3. 간선 리스트

```
[
    [0,1],
    [1,2]
]

- 엣지만 표현
- 간선 위주로 문제를 풀어가는 크루스칼 알고리즘에서 사용
```

### 2. 문제유형

#### 1) DFS : 연결 노드를 Stack에 담음

- 모든 노드를 방문할 때 좋음
- 일단 멀리까지 가야하는 경우 조기 탐색 가능성이 있음 (깊이 찌르면서 가기 때문)
- 대신 얻은 해가 최단 경로라는 보장이 없음
- 사이클 탐지 / 위상 정렬에 적합

#### 2) BFS : 연결 노드를 Queue에 담음(from collections import deque)

- 최단 경로 탐색 (가중치가 없는 경우!!!!!)
- 효율적으로 움직여야 하는 경우 좋음 (가까이 있는 노드부터 탐색하며 이동하기 때문)

\*\*백트래킹: :유망성 검사를 통해 가지치기를 하는 것 (일반적으로 DFS에서 많이 사용하지만 BFS에서도 사용 가능)
즉 더이상 진행해봤자 무의미한 루트는 Stack이나 Queue에 담지 않고 버리는 것

#### 3) 최소 신장 트리 (Minimum Spanning Tree; MST)

- 신장 트리 : N개의 정점이 N-1개의 간선을 가지는 한 줄로 이어진 그래프 (최소 연결 그래프)

- 최소 신장 트리 : 가중치의 합이 최소가 되는 신장 트리

- 가중치가 있는 그래프에서 가중치의 합이 최소가 되는 MST를 찾으라는 형식으로 나온다.

- 간선이 많을 때 프림(PRIM) 알고리즘 사용 - 간만프

```
1. 임의의 정점 선택
2. 인접 정점 중 최소 비용의 간선을 가지는 정점 선택
3. 여기서 인접 정점은 신장 트리와 연결된 모든 정점이 대상
4. 2를 반복
```

#### 크루스칼 알고리즘 (Kruskal)

- 간선이 적을 때 사용 - 간적프

- 트리의 모든 간선을 대상으로 최소 비용 간선을 하나씩 선택 (최소 비용 간선 위주)

- 크루스칼 알고리즘에서는 사이클 검증이 필요하기 때문에 "상호 배타 집합"을 활용한다

```
1. 가중치에 따라 간선을 오름차순 정렬
2. 가중치가 낮은 간선부터 추가
3. 만약 사이클이 만들어지는 간선이면 Pass (상호 배타 집합 활용)
4. 2를 반복
```

\*\*상호 배타 집합 (Disjoint Set)::크루스칼 알고리즘에서 사이클이 형성되는지 확인해야 하는데, 이는 "두 집합이 상호 배타 집합인지 확인"하는 것으로 검증할 수 있다.
```
# 상호배타집합
def make_set(x):
    p[x] = x

def find_set(x):
    if p[x] != x:
        p[x] = find_set(p[x])
    return p[x]

def union(x, y):
    p[find_set(y)] = find_set(x)

```

#### 다익스트라 알고리즘

- 최단 경로 (가중치가 있는 경우)
- 가중치가 없는 그래프는 BFS로 찾을 수 있지만 가중치가 있는 그래프에선 다른 방법이 필요하다.
- 중점에서 다른 모든 점까지의 최단 경로
- 어떤 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘
- 음의 가중치가 허용되지 않음

```
1. 중점으로 거리를 모두 최대값으로 초기화
2. (아직 선택되지 않은 정점 중) 중점으로부터 거리가 최소인 정점을 선택
3. 선택한 가장 가까운 정점을 방문해서 다른 정점으로 가는 경우의 수를 비교해서 최단 거리 갱신
4. 2, 3 반복
```

#### 벨만-포드 알고리즘

- 중점-다른 모든 점까지의 최단 경로
- 음의 가중치 허용

#### 플로이드-워샬 알고리즘

- 모든 정점에 대한 최단 경로
- 동적 계획 알고리즘 (DP)
- 모든 부분에 대하여 [직선거리 vs 경유거리] 중 짧은 경로 선택을 반복

## 힙(heap)

## 투포인터 (대상 배열 1개 / 대상 배열 2개) & 슬라이딩 윈도우

## 해시맵(HashMap)

## Trie (문자열 검색 및 처리)

## Tree
